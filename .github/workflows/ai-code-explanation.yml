name: AI Code Explanation - Documentation Generator

on:
  workflow_dispatch:
    inputs:
      explanation_depth:
        description: 'Depth of code explanation'
        required: false
        default: 'detailed'
        type: choice
        options:
          - basic
          - detailed
          - comprehensive
  pull_request:
    types: [opened, synchronize]
  push:
    branches:
      - main
      - develop

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  analyze-code-complexity:
    name: Analyze Code Complexity
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      complexity_score: ${{ steps.analyze.outputs.score }}
      files_analyzed: ${{ steps.analyze.outputs.files }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Create complexity analyzer
        id: analyze
        run: |
          mkdir -p complexity-analysis
          
          echo "ðŸ” Analyzing code complexity for explanation generation..."
          
          # Create complexity analyzer
          TIMESTAMP=$(date -Iseconds)
          cat > complexity-analysis/analyzer.py << 'EOF_PYTHON'
          #!/usr/bin/env python3
          import os
          import json
          import re
          
          def analyze_javascript_file(filepath):
              """Analyze JavaScript file complexity"""
              with open(filepath, 'r') as f:
                  content = f.read()
              
              # Count various complexity indicators
              functions = len(re.findall(r'function\s+\w+|=>\s*{|:\s*function', content))
              classes = len(re.findall(r'class\s+\w+', content))
              async_ops = len(re.findall(r'async\s+function|await\s+', content))
              conditionals = len(re.findall(r'\b(if|else|switch|case)\b', content))
              loops = len(re.findall(r'\b(for|while|do)\b', content))
              promises = len(re.findall(r'new\s+Promise|\.then\(|\.catch\(', content))
              
              lines = len(content.split('\n'))
              
              # Calculate complexity score (simplified)
              complexity = (
                  functions * 2 +
                  classes * 3 +
                  async_ops * 2.5 +
                  conditionals * 1.5 +
                  loops * 2 +
                  promises * 2
              ) / max(lines, 1) * 100
              
              return {
                  'file': filepath,
                  'lines': lines,
                  'functions': functions,
                  'classes': classes,
                  'async_operations': async_ops,
                  'conditionals': conditionals,
                  'loops': loops,
                  'promises': promises,
                  'complexity_score': round(complexity, 2),
                  'needs_explanation': complexity > 5
              }
          
          def main():
              results = []
              
              # Analyze JavaScript files
              for root, dirs, files in os.walk('.'):
                  # Skip node_modules and .git
                  dirs[:] = [d for d in dirs if d not in ['node_modules', '.git', 'dist']]
                  
                  for file in files:
                      if file.endswith('.js') and not file.endswith('.test.js'):
                          filepath = os.path.join(root, file)
                          try:
                              result = analyze_javascript_file(filepath)
                              results.append(result)
                          except Exception as e:
                              print(f"Error analyzing {filepath}: {e}")
              
              # Save results
              with open('complexity-analysis/results.json', 'w') as f:
                  json.dump({
                      'total_files': len(results),
                      'files': results,
                      'average_complexity': sum(r['complexity_score'] for r in results) / max(len(results), 1)
                  }, f, indent=2)
              
              print(f"Analyzed {len(results)} files")
              
              # Output for GitHub Actions
              avg_complexity = sum(r['complexity_score'] for r in results) / max(len(results), 1)
              print(f"Average complexity: {avg_complexity:.2f}")
              
              return len(results)
          
          if __name__ == '__main__':
              count = main()
          EOF_PYTHON
          
          python3 complexity-analysis/analyzer.py
          
          # Read results
          if [ -f complexity-analysis/results.json ]; then
            FILES_COUNT=$(jq -r '.total_files' complexity-analysis/results.json)
            AVG_COMPLEXITY=$(jq -r '.average_complexity' complexity-analysis/results.json)
            echo "score=$AVG_COMPLEXITY" >> $GITHUB_OUTPUT
            echo "files=$FILES_COUNT" >> $GITHUB_OUTPUT
            
            echo "âœ… Analyzed $FILES_COUNT files with average complexity $AVG_COMPLEXITY"
          fi
      
      - name: Upload analysis results
        uses: actions/upload-artifact@v4
        with:
          name: complexity-analysis
          path: complexity-analysis/
          retention-days: 30

  generate-explanations:
    name: Generate Code Explanations
    needs: analyze-code-complexity
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Download complexity analysis
        uses: actions/download-artifact@v4
        with:
          name: complexity-analysis
          path: complexity-analysis/
      
      - name: Create explanation engine
        run: |
          mkdir -p explanations/engine
          
          cat > explanations/engine/explainer.js << 'EOFENGINE'
          #!/usr/bin/env node
          /**
           * AI Code Explanation Engine
           * Generates human-readable explanations for complex code
           */
          
          class CodeExplainer {
            constructor() {
              this.explanationTemplates = {
                class: this.explainClass.bind(this),
                function: this.explainFunction.bind(this),
                async: this.explainAsync.bind(this),
                promise: this.explainPromise.bind(this),
                eventHandler: this.explainEventHandler.bind(this)
              };
            }
            
            explainClass(code, className) {
              return {
                summary: `The ${className} class provides object-oriented functionality for ${this.inferPurpose(className)}.`,
                details: [
                  `This class encapsulates related data and methods`,
                  `It follows the single responsibility principle`,
                  `Instance methods can be called on class objects`,
                  `Constructor initializes the object state`
                ],
                usage: `const instance = new ${className}(); // Create instance\nawait instance.init(); // Initialize`
              };
            }
            
            explainFunction(code, functionName) {
              const isAsync = code.includes('async');
              const hasParams = /\([^)]+\)/.test(code);
              
              return {
                summary: `The ${functionName} function ${isAsync ? 'asynchronously ' : ''}${this.inferPurpose(functionName)}.`,
                details: [
                  isAsync ? 'This is an asynchronous function that returns a Promise' : 'This is a synchronous function',
                  hasParams ? 'It accepts parameters to customize its behavior' : 'It operates without parameters',
                  'Error handling should be implemented for robustness',
                  'Consider edge cases when using this function'
                ],
                usage: isAsync ? `const result = await ${functionName}(); // Async call` : `const result = ${functionName}(); // Sync call`
              };
            }
            
            explainAsync(code) {
              return {
                summary: 'This code uses asynchronous operations to avoid blocking the main thread.',
                details: [
                  'Async/await syntax makes asynchronous code easier to read',
                  'The await keyword pauses execution until the Promise resolves',
                  'Error handling with try/catch is recommended',
                  'Asynchronous operations improve application responsiveness'
                ],
                usage: 'Use await within async functions to handle Promises sequentially'
              };
            }
            
            explainPromise(code) {
              return {
                summary: 'This code uses Promises to handle asynchronous operations.',
                details: [
                  'Promises represent eventual completion or failure of async operations',
                  'They have three states: pending, fulfilled, or rejected',
                  'Use .then() for success and .catch() for errors',
                  'Promises can be chained for sequential operations'
                ],
                usage: 'promise.then(result => { /* handle success */ }).catch(error => { /* handle error */ })'
              };
            }
            
            explainEventHandler(code, eventType) {
              return {
                summary: `This event handler responds to ${eventType} events in the user interface.`,
                details: [
                  'Event handlers enable interactive user experiences',
                  'They are triggered when specific user actions occur',
                  'preventDefault() can stop default browser behavior',
                  'Event delegation can improve performance for many elements'
                ],
                usage: `element.addEventListener('${eventType}', handlerFunction);`
              };
            }
            
            inferPurpose(name) {
              const lowerName = name.toLowerCase();
              if (lowerName.includes('init')) return 'initialization and setup';
              if (lowerName.includes('process')) return 'data processing';
              if (lowerName.includes('handle')) return 'event handling';
              if (lowerName.includes('get')) return 'data retrieval';
              if (lowerName.includes('set')) return 'data storage';
              if (lowerName.includes('update')) return 'state updates';
              if (lowerName.includes('delete') || lowerName.includes('remove')) return 'data removal';
              if (lowerName.includes('chat')) return 'chat functionality';
              if (lowerName.includes('message')) return 'message management';
              return 'its designated purpose';
            }
            
            generateContextualComments(code) {
              const comments = [];
              
              // Detect patterns and generate comments
              if (code.includes('async') && code.includes('await')) {
                comments.push('// Asynchronous operation - allows non-blocking execution');
              }
              
              if (code.includes('try') && code.includes('catch')) {
                comments.push('// Error handling ensures graceful failure recovery');
              }
              
              if (code.includes('IndexedDB') || code.includes('indexedDB')) {
                comments.push('// Browser database for persistent storage');
              }
              
              if (code.includes('Promise')) {
                comments.push('// Promise-based async pattern for better control flow');
              }
              
              if (code.includes('addEventListener')) {
                comments.push('// Event listener enables interactive user experience');
              }
              
              return comments;
            }
            
            explainCodeBlock(code, type, name) {
              if (this.explanationTemplates[type]) {
                return this.explanationTemplates[type](code, name);
              }
              
              return {
                summary: `This code block performs ${type} operations.`,
                details: ['Review the implementation for specific behavior'],
                usage: 'Refer to documentation for usage examples'
              };
            }
          }
          
          // Example usage
          const explainer = new CodeExplainer();
          
          const classExplanation = explainer.explainClass('class VoBeeChatbot { }', 'VoBeeChatbot');
          console.log('Class Explanation:', JSON.stringify(classExplanation, null, 2));
          
          module.exports = { CodeExplainer };
          EOFENGINE
          
          chmod +x explanations/engine/explainer.js
          node explanations/engine/explainer.js
      
      - name: Generate code documentation
        run: |
          mkdir -p explanations/docs
          
          cat > explanations/docs/chatbot-explained.md << 'EOFEXPLAIN'
          # VoBee Chatbot - Code Explanation
          
          ## Overview
          The VoBee AI Assistant is a sophisticated chatbot application built with modern web technologies. This document provides detailed explanations of the codebase.
          
          ## Core Components
          
          ### VoBeeChatbot Class
          
          **Purpose**: Main chatbot engine that handles conversation logic and data persistence.
          
          #### Constructor
          ```javascript
          constructor() {
            this.dbName = 'VoBeeDB';
            this.dbVersion = 1;
            this.db = null;
            this.conversationHistory = [];
            this.isInitialized = false;
          }
          ```
          
          **Explanation**: 
          - Initializes the chatbot with default configuration
          - Sets up database parameters for IndexedDB
          - Prepares empty conversation history array
          - Tracks initialization state
          
          #### init() Method
          ```javascript
          async init() {
            try {
              await this.initDatabase();
              await this.loadConversationHistory();
              this.isInitialized = true;
            } catch (error) {
              console.error('Failed to initialize VoBee Chatbot:', error);
              this.isInitialized = true; // Continue without persistence
            }
          }
          ```
          
          **Explanation**:
          - **Asynchronous Operation**: Uses async/await for non-blocking initialization
          - **Error Handling**: Gracefully handles database failures
          - **Resilience**: Continues operation even if persistence fails
          - **Sequential Setup**: Ensures database is ready before loading history
          
          #### processMessage() Method
          ```javascript
          async processMessage(userInput) {
            if (!userInput || userInput.trim() === '') {
              return "I didn't catch that. Could you type something? ðŸ";
            }
            
            const category = this.findMatchingCategory(userInput);
            let response;
            
            if (category) {
              response = this.getRandomResponse(category);
            } else {
              await this.logUnrecognizedQuery(userInput);
              response = this.getFallbackResponse();
            }
            
            await this.saveMessage('user', userInput);
            await this.saveMessage('bot', response);
            
            return response;
          }
          ```
          
          **Explanation**:
          - **Input Validation**: Checks for empty or null input
          - **Pattern Matching**: Uses keyword matching to find appropriate response category
          - **Learning Capability**: Logs unrecognized queries for future improvement
          - **Persistence**: Saves both user and bot messages to conversation history
          - **Fallback Mechanism**: Provides creative responses when input is not recognized
          
          ### ChatUI Class
          
          **Purpose**: Manages the user interface and user interactions.
          
          #### Event Handling
          ```javascript
          setupEventListeners() {
            this.sendButton.addEventListener('click', () => this.handleSend());
            this.userInput.addEventListener('keypress', (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSend();
              }
            });
          }
          ```
          
          **Explanation**:
          - **Multiple Input Methods**: Supports both button click and Enter key
          - **Event Delegation**: Uses arrow functions to maintain context
          - **User Experience**: Prevents default Enter behavior for better control
          - **Accessibility**: Provides keyboard navigation support
          
          #### Message Display
          ```javascript
          displayMessage(sender, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = message;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = new Date().toLocaleTimeString([], { 
              hour: '2-digit', 
              minute: '2-digit' 
            });
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timeDiv);
            this.chatMessages.appendChild(messageDiv);
            this.scrollToBottom();
          }
          ```
          
          **Explanation**:
          - **DOM Manipulation**: Creates message elements dynamically
          - **Styling**: Applies appropriate CSS classes for visual distinction
          - **Timestamps**: Adds time information for context
          - **Auto-scroll**: Keeps latest messages visible
          - **Separation of Concerns**: Separates content from presentation
          
          ## IndexedDB Integration
          
          ### Database Schema
          
          **conversations** store:
          - **Purpose**: Persistent storage of chat history
          - **Key Path**: Auto-incrementing ID
          - **Indexes**: Timestamp for chronological queries
          
          **unrecognized_queries** store:
          - **Purpose**: Learning mechanism for improving responses
          - **Key Path**: Auto-incrementing ID
          - **Indexes**: Query text, timestamp, occurrence count
          
          ### Why IndexedDB?
          1. **Browser-native**: No external dependencies required
          2. **Asynchronous**: Non-blocking operations for better UX
          3. **Persistent**: Data survives browser restarts
          4. **Structured**: Supports complex data types and indexes
          
          ## Design Patterns
          
          ### 1. Singleton Pattern
          ```javascript
          const vobee = new VoBeeChatbot();
          ```
          - Global instance ensures consistent state
          - Single source of truth for conversation data
          
          ### 2. Observer Pattern
          ```javascript
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
          ```
          - Event-driven IndexedDB operations
          - Callbacks for async operation completion
          
          ### 3. Factory Pattern
          ```javascript
          getRandomResponse(category) {
            const responses = ResponsePatterns[category];
            return responses[Math.floor(Math.random() * responses.length)];
          }
          ```
          - Dynamic response generation
          - Encapsulated response selection logic
          
          ## Performance Optimizations
          
          ### 1. Lazy Initialization
          - Database connection established only when needed
          - Reduces initial page load time
          
          ### 2. Batched DOM Updates
          - Messages added to DOM after creation
          - Minimizes reflow and repaint operations
          
          ### 3. Indexed Queries
          - IndexedDB indexes for fast data retrieval
          - Efficient searching through conversation history
          
          ## Error Handling Strategy
          
          ### Graceful Degradation
          ```javascript
          try {
            await this.initDatabase();
          } catch (error) {
            console.error('Failed to initialize:', error);
            this.isInitialized = true; // Continue without persistence
          }
          ```
          - Application continues even if IndexedDB fails
          - Degrades to in-memory storage
          - User experience remains functional
          
          ### User-Friendly Messages
          - Technical errors hidden from users
          - Helpful, friendly error messages displayed
          - Maintains chatbot personality even in errors
          
          ## Security Considerations
          
          ### Input Sanitization
          ```javascript
          contentDiv.textContent = message; // Uses textContent, not innerHTML
          ```
          - Prevents XSS attacks
          - Safely handles user input
          
          ### Same-Origin Policy
          - IndexedDB isolated per origin
          - Data not accessible across domains
          
          ## Future Enhancement Opportunities
          
          1. **Machine Learning Integration**: Train models on unrecognized queries
          2. **Natural Language Processing**: Improve pattern matching accuracy
          3. **Context Awareness**: Remember conversation context for better responses
          4. **Sentiment Analysis**: Detect and respond to user emotions
          5. **Multi-language Support**: Expand to support multiple languages
          
          ---
          
          **Generated**: $(date -Iseconds)
          **Version**: 1.0
          **AI Engine**: Code Explanation System
          EOFEXPLAIN
          
          echo "âœ… Generated detailed code explanation documentation"
      
      - name: Generate inline comments
        run: |
          cat > explanations/docs/suggested-comments.md << 'EOFCOMMENTS'
          # Suggested Inline Comments for VoBee Chatbot
          
          ## chatbot.js
          
          ### Line 56-68: initDatabase()
          ```javascript
          // Initialize IndexedDB for persistent storage
          // Creates two object stores:
          // 1. conversations - stores chat history with timestamps
          // 2. unrecognized_queries - tracks unknown inputs for learning
          initDatabase() {
            return new Promise((resolve, reject) => {
              // Request database with version control for schema migrations
              const request = indexedDB.open(this.dbName, this.dbVersion);
              
              // ... implementation
            });
          }
          ```
          
          ### Line 100-123: loadConversationHistory()
          ```javascript
          // Load previous conversations from IndexedDB
          // Enables conversation continuity across browser sessions
          // Returns empty array if database is unavailable
          async loadConversationHistory() {
            if (!this.db) return [];
            
            return new Promise((resolve, reject) => {
              try {
                // Read-only transaction for data retrieval
                const transaction = this.db.transaction([this.stores.conversations], 'readonly');
                const store = transaction.objectStore(this.stores.conversations);
                
                // Retrieve all stored conversations
                const request = store.getAll();
                
                request.onsuccess = () => {
                  this.conversationHistory = request.result || [];
                  resolve(this.conversationHistory);
                };
              } catch (error) {
                console.error('Transaction error:', error);
                reject(error);
              }
            });
          }
          ```
          
          ### Line 310-332: processMessage()
          ```javascript
          /**
           * Process user input and generate appropriate response
           * 
           * Flow:
           * 1. Validate input
           * 2. Match input to response category using keywords
           * 3. Generate random response from matched category
           * 4. Log unrecognized queries for learning
           * 5. Save conversation to history
           * 
           * @param {string} userInput - Raw user message
           * @returns {Promise<string>} Bot's response
           */
          async processMessage(userInput) {
            // Input validation - handle empty strings
            if (!userInput || userInput.trim() === '') {
              return "I didn't catch that. Could you type something? ðŸ";
            }
            
            // Pattern matching using keyword mappings
            const category = this.findMatchingCategory(userInput);
            let response;
            
            if (category) {
              // Matched - get random response for variety
              response = this.getRandomResponse(category);
            } else {
              // Not matched - log for learning and use fallback
              await this.logUnrecognizedQuery(userInput);
              response = this.getFallbackResponse();
            }
            
            // Persist conversation to IndexedDB
            await this.saveMessage('user', userInput);
            await this.saveMessage('bot', response);
            
            return response;
          }
          ```
          
          ### Line 418-437: handleSend()
          ```javascript
          /**
           * Handle send button click or Enter key press
           * 
           * Process:
           * 1. Validate and extract user input
           * 2. Clear input field for next message
           * 3. Display user message immediately
           * 4. Show typing indicator for realism
           * 5. Process message asynchronously
           * 6. Display bot response with delay for natural feel
           */
          async handleSend() {
            const message = this.userInput.value.trim();
            if (!message) return; // Ignore empty messages
            
            this.userInput.value = ''; // Clear input
            this.displayMessage('user', message); // Immediate feedback
            this.showTypingIndicator(); // Visual cue of processing
            
            // Random delay (500-1000ms) for natural conversation feel
            setTimeout(async () => {
              const response = await this.chatbot.processMessage(message);
              this.hideTypingIndicator();
              this.displayMessage('bot', response);
            }, 500 + Math.random() * 500);
          }
          ```
          
          ## Best Practices Demonstrated
          
          ### 1. Async/Await Pattern
          - Makes asynchronous code readable
          - Error handling with try/catch
          - Sequential operations when needed
          
          ### 2. Error Recovery
          - Graceful degradation
          - Fallback mechanisms
          - User-friendly error messages
          
          ### 3. Separation of Concerns
          - VoBeeChatbot: Logic and data
          - ChatUI: Presentation and interaction
          - ResponsePatterns: Content management
          
          ### 4. Progressive Enhancement
          - Core functionality without IndexedDB
          - Enhanced features with persistence
          - PWA capabilities for offline use
          
          ---
          
          **Note**: These comments explain the "why" and "how", not just the "what".
          Good comments add context that isn't obvious from the code itself.
          EOFCOMMENTS
          
          echo "âœ… Generated suggested inline comments"
      
      - name: Create quick reference guide
        run: |
          cat > explanations/docs/quick-reference.md << 'EOFREF'
          # VoBee Chatbot - Quick Reference Guide
          
          ## Key Concepts
          
          ### ðŸŽ¯ Purpose
          - Interactive AI chatbot with learning capabilities
          - Progressive Web App (PWA) with offline support
          - Persistent conversation history using IndexedDB
          
          ### ðŸ—ï¸ Architecture
          
          ```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚         User Interface              â”‚
          â”‚  (index.html + styles.css)          â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚           ChatUI Class              â”‚
          â”‚  - Event handling                   â”‚
          â”‚  - Message display                  â”‚
          â”‚  - User interactions                â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚      VoBeeChatbot Class             â”‚
          â”‚  - Message processing               â”‚
          â”‚  - Pattern matching                 â”‚
          â”‚  - Database operations              â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                 â”‚
                â–¼                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ IndexedDBâ”‚    â”‚ResponsePatternâ”‚
          â”‚  Storage â”‚    â”‚   Mappings    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          ```
          
          ### ðŸ“Š Data Flow
          
          ```
          User Input â†’ Validation â†’ Pattern Matching â†’ Response Selection
                                           â†“
                                    Not Matched?
                                           â†“
                                  Log to Learning DB
                                           â†“
                                   Fallback Response
                                           â†“
                                Save to History â†’ Display
          ```
          
          ## Common Operations
          
          ### Initialize Chatbot
          ```javascript
          const chatbot = new VoBeeChatbot();
          await chatbot.init();
          ```
          
          ### Process Message
          ```javascript
          const response = await chatbot.processMessage('Hello!');
          console.log(response); // "Hi there! ðŸ"
          ```
          
          ### Clear History
          ```javascript
          await chatbot.clearHistory();
          ```
          
          ### Get Unrecognized Queries
          ```javascript
          const queries = await chatbot.getUnrecognizedQueries();
          queries.forEach(q => {
            console.log(`"${q.query}" - seen ${q.count} times`);
          });
          ```
          
          ## Code Patterns
          
          ### Pattern 1: Promise-based IndexedDB
          ```javascript
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.add(data);
            
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
          ```
          
          ### Pattern 2: Error-resilient Async
          ```javascript
          try {
            await riskyOperation();
          } catch (error) {
            console.error('Error:', error);
            // Continue with degraded functionality
          }
          ```
          
          ### Pattern 3: Random Selection
          ```javascript
          const random = items[Math.floor(Math.random() * items.length)];
          ```
          
          ## Performance Tips
          
          1. **Lazy Load**: Initialize database only when needed
          2. **Batch Updates**: Group DOM operations together
          3. **Use Indexes**: IndexedDB queries on indexed fields
          4. **Debounce**: Limit rapid user input processing
          5. **Cache Responses**: Store frequently used patterns
          
          ## Debugging
          
          ### Check IndexedDB
          ```javascript
          // In browser console
          const dbRequest = indexedDB.open('VoBeeDB');
          dbRequest.onsuccess = () => {
            console.log('DB opened:', dbRequest.result);
          };
          ```
          
          ### View Conversation History
          ```javascript
          // In browser console (after chatbot initialized)
          vobee.getHistory().forEach(msg => {
            console.log(`[${msg.sender}]: ${msg.message}`);
          });
          ```
          
          ### Check Unrecognized Queries
          ```javascript
          // In browser console
          vobee.getUnrecognizedQueries().then(queries => {
            console.table(queries);
          });
          ```
          
          ## Extension Points
          
          ### Add New Response Category
          1. Add responses to `ResponsePatterns`
          2. Add keywords to `KeywordMappings`
          3. Test pattern matching
          
          ### Integrate External API
          ```javascript
          async processMessage(userInput) {
            // ... existing validation ...
            
            // Add API call
            if (shouldUseAPI(userInput)) {
              const apiResponse = await fetch('https://api.example.com', {
                method: 'POST',
                body: JSON.stringify({ query: userInput })
              });
              return await apiResponse.json();
            }
            
            // ... existing pattern matching ...
          }
          ```
          
          ### Add Analytics
          ```javascript
          async saveMessage(sender, message) {
            // ... existing save logic ...
            
            // Add analytics tracking
            if (typeof gtag !== 'undefined') {
              gtag('event', 'message_sent', {
                sender: sender,
                length: message.length
              });
            }
          }
          ```
          
          ## Glossary
          
          - **IndexedDB**: Browser-based NoSQL database
          - **PWA**: Progressive Web App - installable web application
          - **Service Worker**: Background script for offline functionality
          - **Pattern Matching**: Keyword-based response selection
          - **Pseudo-learning**: Logging queries for future improvement
          - **Fallback Response**: Default response when no pattern matches
          
          ---
          
          **Generated**: $(date -Iseconds)
          **For**: VoBee AI Assistant v1.0
          EOFREF
          
          echo "âœ… Generated quick reference guide"
      
      - name: Upload explanations
        uses: actions/upload-artifact@v4
        with:
          name: ai-code-explanations
          path: explanations/
          retention-days: 90
      
      - name: Summary
        run: |
          echo "## ðŸ“š AI Code Explanation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Generated Documentation" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Detailed Code Explanation (chatbot-explained.md)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Suggested Inline Comments (suggested-comments.md)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Quick Reference Guide (quick-reference.md)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Code Explanation Engine (explainer.js)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Complexity Analysis" >> $GITHUB_STEP_SUMMARY
          echo "- Files Analyzed: ${{ needs.analyze-code-complexity.outputs.files }}" >> $GITHUB_STEP_SUMMARY
          echo "- Average Complexity: ${{ needs.analyze-code-complexity.outputs.complexity_score }}" >> $GITHUB_STEP_SUMMARY
